// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: svpb/talk.proto

package pb

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	types "github.com/gogo/protobuf/types"
	proto "github.com/golang/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type EventType int32

const (
	Text      EventType = 0
	Boot      EventType = 1
	FaceIn    EventType = 2
	FaceStay  EventType = 3
	FaceLeave EventType = 4
)

var EventType_name = map[int32]string{
	0: "Text",
	1: "Boot",
	2: "FaceIn",
	3: "FaceStay",
	4: "FaceLeave",
}

var EventType_value = map[string]int32{
	"Text":      0,
	"Boot":      1,
	"FaceIn":    2,
	"FaceStay":  3,
	"FaceLeave": 4,
}

func (x EventType) String() string {
	return proto.EnumName(EventType_name, int32(x))
}

func (EventType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_76dcfe22df633968, []int{0}
}

type TalkRequest struct {
	// 消息是否完整
	IsFull bool `protobuf:"varint,1,opt,name=is_full,json=isfull,proto3" json:"isfull"`
	// 语音识别文本信息
	Asr Asr `protobuf:"bytes,2,opt,name=asr,proto3" json:"asr"`
	// 应用ID
	AgentID int64 `protobuf:"varint,3,opt,name=agent_id,json=agentid,proto3" json:"agentid"`
	// 会话ID
	SessionID string `protobuf:"bytes,4,opt,name=session_id,json=sessionid,proto3" json:"sessionid"`
	// 请求ID，每个请求唯一
	QuestionID string `protobuf:"bytes,5,opt,name=question_id,json=questionid,proto3" json:"questionid"`
	// 事件类型
	EventType EventType `protobuf:"varint,6,opt,name=event_type,json=eventtype,proto3,enum=svpb.EventType" json:"eventtype"`
	// 环境信息，如人脸、设备等
	EnvInfo map[string]string `protobuf:"bytes,7,rep,name=env_info,json=envinfo,proto3" json:"envinfo" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// 机器人逻辑ID
	RobotID string `protobuf:"bytes,8,opt,name=robot_id,json=robotid,proto3" json:"robotid"`
	// 租户
	TenantCode string `protobuf:"bytes,9,opt,name=tenant_code,json=tenantcode,proto3" json:"tenantcode"`
	// 机器人所在位置。格式：经度;纬度
	Position string `protobuf:"bytes,10,opt,name=position,proto3" json:"position,omitempty"`
	// HARI 版本，包括 v2，v3
	Version string `protobuf:"bytes,11,opt,name=version,proto3" json:"version,omitempty"`
	// 意图识别的上下文
	InputContext string `protobuf:"bytes,12,opt,name=inputContext,proto3" json:"inputContext,omitempty"`
	// 是否坐席触发
	IsHa                 bool     `protobuf:"varint,13,opt,name=is_ha,proto3" json:"is_ha"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TalkRequest) Reset()         { *m = TalkRequest{} }
func (m *TalkRequest) String() string { return proto.CompactTextString(m) }
func (*TalkRequest) ProtoMessage()    {}
func (*TalkRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_76dcfe22df633968, []int{0}
}
func (m *TalkRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TalkRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TalkRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TalkRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TalkRequest.Merge(m, src)
}
func (m *TalkRequest) XXX_Size() int {
	return m.Size()
}
func (m *TalkRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TalkRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TalkRequest proto.InternalMessageInfo

type TalkResponse struct {
	// 语音识别结果类型
	Source string `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	// 语音识别文本信息
	Asr       Asr           `protobuf:"bytes,2,opt,name=asr,proto3" json:"asr"`
	Operation *types.Struct `protobuf:"bytes,3,opt,name=operation,proto3" json:"operation,omitempty"`
	// 当前回答是否可信
	IsCredible bool `protobuf:"varint,4,opt,name=is_credible,json=iscredible,proto3" json:"iscredible"`
	// 当前回答自信度
	Confidence float64 `protobuf:"fixed64,5,opt,name=confidence,proto3" json:"confidence,omitempty"`
	// 回答内容
	Tts []AnsItem `protobuf:"bytes,6,rep,name=tts,proto3" json:"tts"`
	// 标签信息
	Tags []string `protobuf:"bytes,7,rep,name=tags,proto3" json:"tags,omitempty"`
	// QA推荐答案
	Recomendation []AnsItem `protobuf:"bytes,8,rep,name=recomendation,proto3" json:"recomendation"`
	// 相似问题
	Simqs []string `protobuf:"bytes,9,rep,name=simqs,proto3" json:"simqs,omitempty"`
	// gateway 透传字段
	GwData *types.Struct `protobuf:"bytes,10,opt,name=gw_data,json=gwdata,proto3" json:"gwdata"`
	// 多轮会话下一个分支树
	Tree Tree `protobuf:"bytes,11,opt,name=tree,proto3" json:"tree"`
	// 会话超时字段
	Expiration int64 `protobuf:"varint,12,opt,name=expiration,proto3" json:"expiration,omitempty"`
	// 请求耗时
	Cost int64 `protobuf:"varint,13,opt,name=cost,json=thirdCost,proto3" json:"thirdCost"`
	// 日志字段，smartvoice 自己使用
	HitLog *types.Struct `protobuf:"bytes,14,opt,name=hit_log,json=hitlog,proto3" json:"hitlog"`
	// 调试日志，smartvoice自己使用
	DebugList            []HitLogDebug `protobuf:"bytes,15,rep,name=debug_list,json=debugList,proto3" json:"debugList"`
	QuestionID           string        `protobuf:"bytes,16,opt,name=question_id,json=questionid,proto3" json:"questionid"`
	Emotion              *Emotion      `protobuf:"bytes,17,opt,name=emotion,proto3" json:"emotion"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TalkResponse) Reset()         { *m = TalkResponse{} }
func (m *TalkResponse) String() string { return proto.CompactTextString(m) }
func (*TalkResponse) ProtoMessage()    {}
func (*TalkResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_76dcfe22df633968, []int{1}
}
func (m *TalkResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TalkResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TalkResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TalkResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TalkResponse.Merge(m, src)
}
func (m *TalkResponse) XXX_Size() int {
	return m.Size()
}
func (m *TalkResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TalkResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TalkResponse proto.InternalMessageInfo

type Emotion struct {
	// 用户输入文本的情感
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// 情感执行度
	Score                float64  `protobuf:"fixed64,2,opt,name=score,proto3" json:"score,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Emotion) Reset()         { *m = Emotion{} }
func (m *Emotion) String() string { return proto.CompactTextString(m) }
func (*Emotion) ProtoMessage()    {}
func (*Emotion) Descriptor() ([]byte, []int) {
	return fileDescriptor_76dcfe22df633968, []int{2}
}
func (m *Emotion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Emotion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Emotion.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Emotion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Emotion.Merge(m, src)
}
func (m *Emotion) XXX_Size() int {
	return m.Size()
}
func (m *Emotion) XXX_DiscardUnknown() {
	xxx_messageInfo_Emotion.DiscardUnknown(m)
}

var xxx_messageInfo_Emotion proto.InternalMessageInfo

type Asr struct {
	// 语音识别结果
	Lang string `protobuf:"bytes,1,opt,name=lang,proto3" json:"lang,omitempty"`
	// 识别语音，由Hari传入，包括：CH、TCH、EN、JA、ES
	Text                 string   `protobuf:"bytes,2,opt,name=text,proto3" json:"text,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Asr) Reset()         { *m = Asr{} }
func (m *Asr) String() string { return proto.CompactTextString(m) }
func (*Asr) ProtoMessage()    {}
func (*Asr) Descriptor() ([]byte, []int) {
	return fileDescriptor_76dcfe22df633968, []int{3}
}
func (m *Asr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Asr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Asr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Asr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Asr.Merge(m, src)
}
func (m *Asr) XXX_Size() int {
	return m.Size()
}
func (m *Asr) XXX_DiscardUnknown() {
	xxx_messageInfo_Asr.DiscardUnknown(m)
}

var xxx_messageInfo_Asr proto.InternalMessageInfo

type AnsItem struct {
	// 回答内容
	Text string `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty"`
	// 回答语言
	Lang string `protobuf:"bytes,2,opt,name=lang,proto3" json:"lang,omitempty"`
	// tts需要操作类型
	Type string `protobuf:"bytes,3,opt,name=type,proto3" json:"type,omitempty"`
	// RCU 端执行对象
	Action Action `protobuf:"bytes,4,opt,name=action,proto3" json:"action"`
	// 表情字段
	Emoji string `protobuf:"bytes,5,opt,name=emoji,proto3" json:"emoji,omitempty"`
	// 业务扩展字段
	Payload string `protobuf:"bytes,6,opt,name=payload,proto3" json:"payload,omitempty"`
	//sv返回的下文
	Outcontext           string   `protobuf:"bytes,7,opt,name=outcontext,proto3" json:"outcontext,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AnsItem) Reset()         { *m = AnsItem{} }
func (m *AnsItem) String() string { return proto.CompactTextString(m) }
func (*AnsItem) ProtoMessage()    {}
func (*AnsItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_76dcfe22df633968, []int{4}
}
func (m *AnsItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AnsItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AnsItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AnsItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AnsItem.Merge(m, src)
}
func (m *AnsItem) XXX_Size() int {
	return m.Size()
}
func (m *AnsItem) XXX_DiscardUnknown() {
	xxx_messageInfo_AnsItem.DiscardUnknown(m)
}

var xxx_messageInfo_AnsItem proto.InternalMessageInfo

type Action struct {
	// action名，RCU执行范畴
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// 用户RCU显示的识别串，具体枚举值由各业务模块定义
	Display              string      `protobuf:"bytes,2,opt,name=display,proto3" json:"display,omitempty"`
	Param                ActionParam `protobuf:"bytes,3,opt,name=param,proto3" json:"param"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Action) Reset()         { *m = Action{} }
func (m *Action) String() string { return proto.CompactTextString(m) }
func (*Action) ProtoMessage()    {}
func (*Action) Descriptor() ([]byte, []int) {
	return fileDescriptor_76dcfe22df633968, []int{5}
}
func (m *Action) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Action) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Action.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Action) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Action.Merge(m, src)
}
func (m *Action) XXX_Size() int {
	return m.Size()
}
func (m *Action) XXX_DiscardUnknown() {
	xxx_messageInfo_Action.DiscardUnknown(m)
}

var xxx_messageInfo_Action proto.InternalMessageInfo

type ActionParam struct {
	Duration float64 `protobuf:"fixed64,1,opt,name=duration,proto3" json:"duration,omitempty"`
	// 音频文件URL
	Url string `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
	// 图片文件URL
	PicUrl string `protobuf:"bytes,3,opt,name=pic_url,proto3" json:"pic_url"`
	// 视频文件URL
	VideoUrl string `protobuf:"bytes,4,opt,name=video_url,proto3" json:"video_url"`
	// 意图名称
	Intent string `protobuf:"bytes,5,opt,name=intent,proto3" json:"intent,omitempty"`
	// 意图参数
	Params map[string]string `protobuf:"bytes,6,rep,name=params,proto3" json:"params,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// 给rcu处理的原始数据json字符串
	RawData *types.Value `protobuf:"bytes,7,opt,name=raw_data,proto3" json:"raw_data"`
	// 序号，从0开始
	FrameNo int32 `protobuf:"varint,8,opt,name=frame_no,proto3" json:"frame_no,omitempty"`
	// 类型，目前支持：voicepad（垫片）、tts（正文）
	PlayType string `protobuf:"bytes,9,opt,name=play_type,proto3" json:"play_type,omitempty"`
	GuideTip string `protobuf:"bytes,10,opt,name=guide_tip,proto3" json:"guide_tip,omitempty"`
	// 领域名称
	Domain               string   `protobuf:"bytes,11,opt,name=domain,proto3" json:"domain,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ActionParam) Reset()         { *m = ActionParam{} }
func (m *ActionParam) String() string { return proto.CompactTextString(m) }
func (*ActionParam) ProtoMessage()    {}
func (*ActionParam) Descriptor() ([]byte, []int) {
	return fileDescriptor_76dcfe22df633968, []int{6}
}
func (m *ActionParam) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionParam) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionParam.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionParam) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionParam.Merge(m, src)
}
func (m *ActionParam) XXX_Size() int {
	return m.Size()
}
func (m *ActionParam) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionParam.DiscardUnknown(m)
}

var xxx_messageInfo_ActionParam proto.InternalMessageInfo

type Tree struct {
	CurrentState         string        `protobuf:"bytes,1,opt,name=current_state,json=currentState,proto3" json:"current_state,omitempty"`
	SubTree              []SubTreeItem `protobuf:"bytes,2,rep,name=sub_tree,json=subTree,proto3" json:"sub_tree"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Tree) Reset()         { *m = Tree{} }
func (m *Tree) String() string { return proto.CompactTextString(m) }
func (*Tree) ProtoMessage()    {}
func (*Tree) Descriptor() ([]byte, []int) {
	return fileDescriptor_76dcfe22df633968, []int{7}
}
func (m *Tree) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tree) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tree.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tree) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tree.Merge(m, src)
}
func (m *Tree) XXX_Size() int {
	return m.Size()
}
func (m *Tree) XXX_DiscardUnknown() {
	xxx_messageInfo_Tree.DiscardUnknown(m)
}

var xxx_messageInfo_Tree proto.InternalMessageInfo

type SubTreeItem struct {
	State                string   `protobuf:"bytes,1,opt,name=state,proto3" json:"state,omitempty"`
	Template             string   `protobuf:"bytes,2,opt,name=template,proto3" json:"template,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SubTreeItem) Reset()         { *m = SubTreeItem{} }
func (m *SubTreeItem) String() string { return proto.CompactTextString(m) }
func (*SubTreeItem) ProtoMessage()    {}
func (*SubTreeItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_76dcfe22df633968, []int{8}
}
func (m *SubTreeItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubTreeItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubTreeItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubTreeItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubTreeItem.Merge(m, src)
}
func (m *SubTreeItem) XXX_Size() int {
	return m.Size()
}
func (m *SubTreeItem) XXX_DiscardUnknown() {
	xxx_messageInfo_SubTreeItem.DiscardUnknown(m)
}

var xxx_messageInfo_SubTreeItem proto.InternalMessageInfo

type HitLogDebug struct {
	Source               string            `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	DomainId             int64             `protobuf:"varint,2,opt,name=domain_id,json=domainId,proto3" json:"domain_id,omitempty"`
	Domain               string            `protobuf:"bytes,3,opt,name=domain,proto3" json:"domain,omitempty"`
	IntentId             int64             `protobuf:"varint,4,opt,name=intent_id,json=intentId,proto3" json:"intent_id,omitempty"`
	Intent               string            `protobuf:"bytes,5,opt,name=intent,proto3" json:"intent,omitempty"`
	InContext            string            `protobuf:"bytes,6,opt,name=in_context,json=inContext,proto3" json:"in_context,omitempty"`
	OutContext           string            `protobuf:"bytes,7,opt,name=out_context,json=outContext,proto3" json:"out_context,omitempty"`
	Response             string            `protobuf:"bytes,8,opt,name=response,proto3" json:"response,omitempty"`
	Time                 string            `protobuf:"bytes,9,opt,name=time,proto3" json:"time,omitempty"`
	Supplier             string            `protobuf:"bytes,10,opt,name=supplier,proto3" json:"supplier,omitempty"`
	SupplierType         string            `protobuf:"bytes,11,opt,name=supplier_type,json=supplierType,proto3" json:"supplier_type,omitempty"`
	Cost                 int64             `protobuf:"varint,12,opt,name=cost,proto3" json:"cost,omitempty"`
	Algo                 string            `protobuf:"bytes,13,opt,name=algo,proto3" json:"algo,omitempty"`
	Parameters           map[string]string `protobuf:"bytes,14,rep,name=parameters,proto3" json:"parameters,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *HitLogDebug) Reset()         { *m = HitLogDebug{} }
func (m *HitLogDebug) String() string { return proto.CompactTextString(m) }
func (*HitLogDebug) ProtoMessage()    {}
func (*HitLogDebug) Descriptor() ([]byte, []int) {
	return fileDescriptor_76dcfe22df633968, []int{9}
}
func (m *HitLogDebug) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HitLogDebug) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HitLogDebug.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HitLogDebug) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HitLogDebug.Merge(m, src)
}
func (m *HitLogDebug) XXX_Size() int {
	return m.Size()
}
func (m *HitLogDebug) XXX_DiscardUnknown() {
	xxx_messageInfo_HitLogDebug.DiscardUnknown(m)
}

var xxx_messageInfo_HitLogDebug proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("svpb.EventType", EventType_name, EventType_value)
	proto.RegisterType((*TalkRequest)(nil), "svpb.TalkRequest")
	proto.RegisterMapType((map[string]string)(nil), "svpb.TalkRequest.EnvInfoEntry")
	proto.RegisterType((*TalkResponse)(nil), "svpb.TalkResponse")
	proto.RegisterType((*Emotion)(nil), "svpb.Emotion")
	proto.RegisterType((*Asr)(nil), "svpb.Asr")
	proto.RegisterType((*AnsItem)(nil), "svpb.AnsItem")
	proto.RegisterType((*Action)(nil), "svpb.Action")
	proto.RegisterType((*ActionParam)(nil), "svpb.ActionParam")
	proto.RegisterMapType((map[string]string)(nil), "svpb.ActionParam.ParamsEntry")
	proto.RegisterType((*Tree)(nil), "svpb.Tree")
	proto.RegisterType((*SubTreeItem)(nil), "svpb.SubTreeItem")
	proto.RegisterType((*HitLogDebug)(nil), "svpb.HitLogDebug")
	proto.RegisterMapType((map[string]string)(nil), "svpb.HitLogDebug.ParametersEntry")
}

func init() { proto.RegisterFile("svpb/talk.proto", fileDescriptor_76dcfe22df633968) }

var fileDescriptor_76dcfe22df633968 = []byte{
	// 1509 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x57, 0x51, 0x6f, 0x1b, 0xc7,
	0x11, 0xd6, 0x89, 0x14, 0xc9, 0x1b, 0x52, 0x36, 0xb5, 0x68, 0xdd, 0x03, 0xe3, 0x90, 0x0a, 0xd3,
	0x14, 0x82, 0x0b, 0x93, 0x2d, 0xd3, 0x00, 0xb5, 0x11, 0xa3, 0x35, 0x1d, 0x07, 0x51, 0xe1, 0x87,
	0x76, 0x65, 0xf4, 0xf5, 0x70, 0xe4, 0xad, 0x4e, 0x5b, 0x1f, 0x6f, 0x2f, 0xb7, 0x7b, 0x8c, 0xf5,
	0xd8, 0xfe, 0x82, 0x02, 0x7d, 0xe9, 0x0f, 0xe8, 0x1f, 0xe9, 0x9b, 0x81, 0xbe, 0x04, 0xe8, 0x3b,
	0xd1, 0xa8, 0x7d, 0xd2, 0xaf, 0x28, 0x66, 0x76, 0x8f, 0xbc, 0x58, 0x31, 0x60, 0xbd, 0xe8, 0x66,
	0xbe, 0x99, 0x59, 0xce, 0xce, 0x7e, 0x33, 0xbb, 0x82, 0xbb, 0x7a, 0x9d, 0x2f, 0xa6, 0x26, 0x4a,
	0x5f, 0x4d, 0xf2, 0x42, 0x19, 0xc5, 0x9a, 0x08, 0x0c, 0x1e, 0x26, 0xd2, 0x5c, 0x94, 0x8b, 0xc9,
	0x52, 0xad, 0xa6, 0x89, 0x4a, 0xd4, 0x94, 0x8c, 0x8b, 0xf2, 0x9c, 0x34, 0x52, 0x48, 0xb2, 0x41,
	0x83, 0xfb, 0x89, 0x52, 0x49, 0x2a, 0x76, 0x5e, 0xda, 0x14, 0xe5, 0xd2, 0xbc, 0x65, 0x8d, 0x72,
	0x39, 0x8d, 0xb2, 0x4c, 0x99, 0xc8, 0x48, 0x95, 0x69, 0x6b, 0x1d, 0xff, 0xe3, 0x00, 0xba, 0x2f,
	0xa3, 0xf4, 0x15, 0x17, 0x5f, 0x97, 0x42, 0x1b, 0xf6, 0x31, 0xb4, 0xa5, 0x0e, 0xcf, 0xcb, 0x34,
	0x0d, 0xbc, 0x63, 0xef, 0xa4, 0x33, 0x87, 0xeb, 0xcd, 0xa8, 0x25, 0x35, 0x22, 0xdc, 0x7d, 0xd9,
	0x47, 0xd0, 0x88, 0x74, 0x11, 0xec, 0x1f, 0x7b, 0x27, 0xdd, 0x99, 0x3f, 0xc1, 0x9c, 0x27, 0x4f,
	0x75, 0x31, 0x6f, 0xbe, 0xd9, 0x8c, 0xf6, 0x38, 0xda, 0xd8, 0x2f, 0xa1, 0x13, 0x25, 0x22, 0x33,
	0xa1, 0x8c, 0x83, 0xc6, 0xb1, 0x77, 0xd2, 0x98, 0xdf, 0xbb, 0xda, 0x8c, 0xda, 0x4f, 0x11, 0x3b,
	0xfd, 0xe2, 0x7a, 0x33, 0x6a, 0x93, 0x59, 0xc6, 0xbc, 0x12, 0xd8, 0x23, 0x00, 0x2d, 0xb4, 0x96,
	0x2a, 0xc3, 0xa0, 0xe6, 0xb1, 0x77, 0xe2, 0xcf, 0x07, 0x57, 0x9b, 0x91, 0x7f, 0x66, 0x51, 0x0a,
	0xf3, 0x9d, 0x8b, 0x8c, 0xf9, 0x4e, 0x64, 0x4f, 0xa0, 0x4b, 0xe9, 0xbb, 0xd8, 0x03, 0x8a, 0xbd,
	0x7f, 0xb5, 0x19, 0xc1, 0x1f, 0x1c, 0x4c, 0xc1, 0x50, 0x39, 0xc9, 0x98, 0xd7, 0x64, 0xf6, 0x04,
	0x40, 0xac, 0x31, 0x59, 0x73, 0x99, 0x8b, 0xa0, 0x75, 0xec, 0x9d, 0xdc, 0x99, 0xdd, 0xb5, 0xdb,
	0x7a, 0x8e, 0xf8, 0xcb, 0xcb, 0x5c, 0xcc, 0x0f, 0xf1, 0xd7, 0xc9, 0x0d, 0xbd, 0xf8, 0x4e, 0x64,
	0x5f, 0x42, 0x47, 0x64, 0xeb, 0x50, 0x66, 0xe7, 0x2a, 0x68, 0x1f, 0x37, 0x4e, 0xba, 0xb3, 0xa1,
	0x0d, 0xae, 0x15, 0x76, 0xf2, 0x3c, 0x5b, 0x9f, 0x66, 0xe7, 0xea, 0x79, 0x66, 0x8a, 0xcb, 0x79,
	0x17, 0x0b, 0x20, 0xb2, 0x35, 0x86, 0xf0, 0x4a, 0xc0, 0x9a, 0x15, 0x6a, 0xa1, 0xa8, 0x66, 0x1d,
	0xda, 0x02, 0xd5, 0x8c, 0x23, 0x66, 0x6b, 0x46, 0x66, 0xac, 0x99, 0x13, 0xd8, 0x14, 0xba, 0x46,
	0x64, 0x51, 0x66, 0xc2, 0xa5, 0x8a, 0x45, 0xe0, 0x53, 0xd4, 0x1d, 0xdc, 0xaa, 0x85, 0x11, 0xe5,
	0x35, 0x99, 0x0d, 0xa0, 0x93, 0x2b, 0x2d, 0x71, 0xe3, 0x01, 0xa0, 0x37, 0xdf, 0xea, 0x2c, 0x80,
	0xf6, 0x5a, 0x14, 0x58, 0xd2, 0xa0, 0x4b, 0xa6, 0x4a, 0x65, 0x63, 0xe8, 0xc9, 0x2c, 0x2f, 0xcd,
	0x33, 0x95, 0x19, 0xf1, 0xda, 0x04, 0x3d, 0x32, 0x7f, 0x0f, 0x63, 0x23, 0x38, 0x90, 0x3a, 0xbc,
	0x88, 0x82, 0x43, 0xe2, 0x8d, 0x7f, 0xbd, 0x19, 0x59, 0x80, 0xdb, 0xcf, 0xe0, 0x31, 0xf4, 0xea,
	0x45, 0x60, 0x7d, 0x68, 0xbc, 0x12, 0x97, 0x44, 0x33, 0x9f, 0xa3, 0xc8, 0x7e, 0x04, 0x07, 0xeb,
	0x28, 0x2d, 0x05, 0x31, 0xcb, 0xe7, 0x56, 0x79, 0xbc, 0xff, 0x6b, 0x6f, 0xfc, 0xe7, 0x16, 0xf4,
	0x6c, 0x35, 0x75, 0xae, 0x32, 0x2d, 0xd8, 0x3d, 0x68, 0x69, 0x55, 0x16, 0x4b, 0xe1, 0xe2, 0x9d,
	0xf6, 0x3e, 0xd4, 0xfc, 0x0c, 0x7c, 0x95, 0x8b, 0x82, 0xda, 0x80, 0xb8, 0xd9, 0x9d, 0xfd, 0x64,
	0x62, 0x9b, 0x64, 0x52, 0xb5, 0xd0, 0xe4, 0x8c, 0x5a, 0x88, 0xef, 0x3c, 0xb1, 0xd4, 0x52, 0x87,
	0xcb, 0x42, 0xc4, 0x72, 0x91, 0x0a, 0xe2, 0x67, 0xc7, 0x96, 0x5a, 0xea, 0x0a, 0xe5, 0x35, 0x99,
	0x0d, 0x01, 0x96, 0x2a, 0x3b, 0x97, 0xb1, 0xc8, 0x96, 0x82, 0x38, 0xe9, 0xf1, 0x1a, 0xc2, 0x3e,
	0x81, 0x86, 0x31, 0x3a, 0x68, 0x11, 0x63, 0x0e, 0x5d, 0xaa, 0x99, 0x3e, 0x35, 0x62, 0x55, 0xa5,
	0x6b, 0x8c, 0x66, 0x0c, 0x9a, 0x26, 0x4a, 0x34, 0x31, 0xcb, 0xe7, 0x24, 0xb3, 0x47, 0x70, 0x58,
	0x88, 0xa5, 0x5a, 0x89, 0x2c, 0xb6, 0xdb, 0xe8, 0xbc, 0x7b, 0x91, 0xef, 0x7b, 0x62, 0x8d, 0xb5,
	0x5c, 0x7d, 0xad, 0x03, 0x9f, 0xd6, 0xb3, 0x0a, 0xfb, 0x1c, 0xda, 0xc9, 0x37, 0x61, 0x1c, 0x99,
	0x88, 0x58, 0xf1, 0xee, 0x8a, 0xd8, 0x79, 0x90, 0x7c, 0x83, 0xae, 0xdc, 0x7d, 0xd9, 0x4f, 0xa1,
	0x69, 0x0a, 0x21, 0x88, 0x35, 0xdd, 0x19, 0x38, 0xf2, 0x17, 0x42, 0xb8, 0x14, 0xc8, 0x8a, 0xf5,
	0x10, 0xaf, 0x73, 0xe9, 0x0a, 0x8f, 0x14, 0x6a, 0xf0, 0x1a, 0xc2, 0x7e, 0x06, 0xcd, 0xa5, 0xd2,
	0x86, 0xf8, 0xd3, 0xb0, 0xed, 0x66, 0x2e, 0x64, 0x11, 0x3f, 0x53, 0xda, 0xf0, 0x9d, 0x88, 0xb9,
	0x5e, 0x48, 0x13, 0xa6, 0x2a, 0x09, 0xee, 0xbc, 0x47, 0xae, 0x17, 0xd2, 0xa4, 0x2a, 0xe1, 0xee,
	0xcb, 0x9e, 0x01, 0xc4, 0x62, 0x51, 0x26, 0x61, 0x2a, 0xb5, 0x09, 0xee, 0x52, 0xdd, 0x8e, 0x6c,
	0xc6, 0x5f, 0x49, 0xf3, 0x42, 0x25, 0x5f, 0xa0, 0x75, 0x7e, 0x84, 0x89, 0x63, 0x0a, 0xe4, 0xfc,
	0x42, 0x62, 0x0a, 0x5b, 0xf1, 0xed, 0x79, 0xd3, 0xbf, 0xe5, 0xbc, 0xf9, 0x15, 0xb4, 0xc5, 0x4a,
	0x51, 0x19, 0x8e, 0x68, 0x07, 0xee, 0xe0, 0x9e, 0x5b, 0xd0, 0x8d, 0x07, 0xab, 0xf0, 0x4a, 0x18,
	0x7f, 0x0a, 0x6d, 0xe7, 0x80, 0x9c, 0xc8, 0xa2, 0x55, 0xc5, 0x7d, 0x92, 0xe9, 0x60, 0x97, 0xaa,
	0xb0, 0xcd, 0xe3, 0x71, 0xab, 0x8c, 0x1f, 0x42, 0xe3, 0xa9, 0x2e, 0x30, 0x20, 0x8d, 0xb2, 0xa4,
	0x0a, 0x40, 0x99, 0x88, 0x85, 0xcd, 0x6c, 0x9b, 0x8d, 0xe4, 0xf1, 0x3f, 0x3d, 0x68, 0x3b, 0xfa,
	0x6c, 0xed, 0xde, 0xce, 0xbe, 0x5d, 0x67, 0xff, 0xad, 0x75, 0x70, 0x6e, 0x36, 0x9c, 0x1f, 0x8e,
	0xc4, 0x07, 0xd0, 0x8a, 0x96, 0xb4, 0xc1, 0x26, 0x6d, 0xb0, 0xe7, 0x98, 0x49, 0x98, 0x63, 0x85,
	0xf3, 0xc0, 0xc4, 0xc5, 0x4a, 0xfd, 0x49, 0xda, 0xb1, 0xcd, 0xad, 0x82, 0xc3, 0x28, 0x8f, 0x2e,
	0x53, 0x15, 0xc5, 0x34, 0x90, 0x7d, 0x5e, 0xa9, 0xc8, 0x23, 0x55, 0x9a, 0xa5, 0x1b, 0x45, 0x6d,
	0x32, 0xd6, 0x90, 0xb1, 0x80, 0x96, 0xfd, 0x9d, 0x1f, 0x2c, 0x53, 0x00, 0xed, 0x58, 0xea, 0x3c,
	0x8d, 0x2e, 0xdd, 0x26, 0x2a, 0x95, 0x3d, 0x84, 0x83, 0x3c, 0x2a, 0xa2, 0x95, 0x9b, 0x09, 0x47,
	0xf5, 0x94, 0x7f, 0x8f, 0x06, 0x97, 0xb7, 0xf5, 0x1a, 0xff, 0xab, 0x01, 0xdd, 0x9a, 0x11, 0x27,
	0x6b, 0x5c, 0x3a, 0x72, 0x7b, 0x74, 0x04, 0x5b, 0x1d, 0x47, 0x5d, 0x59, 0xa4, 0xee, 0x07, 0x51,
	0x64, 0x9f, 0x40, 0x3b, 0x97, 0xcb, 0x10, 0x51, 0xaa, 0x9b, 0x3d, 0x73, 0x07, 0xf1, 0x4a, 0x60,
	0x3f, 0x07, 0x7f, 0x2d, 0x63, 0xa1, 0xc8, 0xd1, 0x5e, 0x89, 0xd4, 0x18, 0x5b, 0x90, 0xef, 0x44,
	0x9c, 0x89, 0x32, 0x33, 0x22, 0x33, 0xae, 0x92, 0x4e, 0x63, 0x9f, 0x41, 0x8b, 0x52, 0xae, 0x66,
	0xcd, 0x87, 0x37, 0x76, 0x36, 0xa1, 0xbf, 0x9a, 0xe6, 0x32, 0x77, 0xce, 0xec, 0xb7, 0xd0, 0x29,
	0x22, 0x37, 0x14, 0xda, 0x54, 0x92, 0x7b, 0x37, 0x1a, 0xed, 0x8f, 0x38, 0xa1, 0xe7, 0xbd, 0xeb,
	0xcd, 0x68, 0xeb, 0xcb, 0xb7, 0x12, 0x96, 0xe4, 0xbc, 0x88, 0x56, 0x22, 0xcc, 0x14, 0x5d, 0x68,
	0x07, 0x7c, 0xab, 0xb3, 0xfb, 0xe0, 0x63, 0xd5, 0xed, 0x95, 0x4b, 0xf7, 0x16, 0xdf, 0x01, 0x68,
	0x4d, 0x4a, 0x19, 0x8b, 0xd0, 0xc8, 0xdc, 0xdd, 0x53, 0x3b, 0x00, 0x37, 0x1a, 0xab, 0x55, 0x24,
	0xab, 0x7b, 0xca, 0x69, 0x83, 0x47, 0xd0, 0xad, 0x6d, 0xe4, 0x56, 0x17, 0x4c, 0x08, 0x4d, 0x1c,
	0x58, 0xec, 0x63, 0x38, 0x5c, 0x96, 0x45, 0x81, 0x8f, 0x01, 0x6d, 0x22, 0x53, 0x71, 0xa7, 0xe7,
	0xc0, 0x33, 0xc4, 0xd8, 0x0c, 0x3a, 0xba, 0x5c, 0x84, 0x34, 0xf3, 0xf6, 0xeb, 0x13, 0xe4, 0xac,
	0x5c, 0xe0, 0x2a, 0xb5, 0xe9, 0xdb, 0xd6, 0x16, 0x1a, 0xff, 0x06, 0xba, 0x35, 0x2b, 0x75, 0x6b,
	0x6d, 0x7d, 0xab, 0x60, 0xc1, 0x8c, 0x58, 0xe5, 0x29, 0x1a, 0x6c, 0x8a, 0x5b, 0x7d, 0x7c, 0xdd,
	0x80, 0x6e, 0x6d, 0x42, 0xbd, 0xf3, 0x06, 0xfc, 0x00, 0x7c, 0x5b, 0x0e, 0x9c, 0x4c, 0xfb, 0x34,
	0x65, 0x3b, 0x16, 0x38, 0x8d, 0x6b, 0x95, 0x6b, 0xd4, 0x2b, 0x87, 0x41, 0x96, 0x2c, 0xd5, 0xd3,
	0xab, 0xc1, 0x3b, 0x16, 0xb0, 0x41, 0x3f, 0xc8, 0xab, 0x0f, 0x01, 0x64, 0x16, 0x56, 0x8d, 0x68,
	0xbb, 0xd4, 0x97, 0xd9, 0xee, 0x41, 0xd0, 0x55, 0xa5, 0x09, 0x6f, 0x36, 0x6a, 0xe5, 0x30, 0x80,
	0x4e, 0xe1, 0xee, 0x73, 0xfb, 0xde, 0xe1, 0x5b, 0x9d, 0x86, 0x8a, 0x5c, 0x55, 0xcc, 0x20, 0x19,
	0xfd, 0x75, 0x99, 0xe7, 0xa9, 0x14, 0x45, 0xf5, 0x76, 0xa9, 0x74, 0x3c, 0xb7, 0x4a, 0xb6, 0x94,
	0xb2, 0xcc, 0xe8, 0x55, 0x20, 0x3e, 0xe1, 0x70, 0x51, 0xba, 0x61, 0xec, 0xdd, 0x43, 0x32, 0x62,
	0x51, 0x9a, 0x28, 0xba, 0x75, 0x7c, 0x4e, 0x32, 0x7b, 0x0a, 0x40, 0x3d, 0x20, 0x8c, 0x28, 0x74,
	0x70, 0x87, 0x4e, 0xf8, 0xa3, 0x1b, 0x77, 0x84, 0x6d, 0x1a, 0xf2, 0xb1, 0x8d, 0x53, 0x0b, 0x1a,
	0x3c, 0x81, 0xbb, 0x6f, 0x99, 0x6f, 0x43, 0xc7, 0x07, 0x5f, 0x81, 0xbf, 0x7d, 0x79, 0xb2, 0x0e,
	0x34, 0x5f, 0x8a, 0xd7, 0xa6, 0xbf, 0x87, 0xd2, 0x5c, 0x29, 0xd3, 0xf7, 0x18, 0x40, 0xeb, 0xcb,
	0x68, 0x29, 0x4e, 0xb3, 0xfe, 0x3e, 0xeb, 0x41, 0x07, 0xe5, 0x33, 0x13, 0x5d, 0xf6, 0x1b, 0xec,
	0x10, 0x7c, 0xd4, 0x5e, 0x88, 0x68, 0x2d, 0xfa, 0xcd, 0xd9, 0x5f, 0x3d, 0x68, 0xe2, 0xcb, 0x89,
	0xfd, 0xce, 0x7d, 0x8f, 0x6e, 0xbc, 0x4d, 0x07, 0xac, 0x0e, 0xd9, 0x03, 0x18, 0x7f, 0xf0, 0x97,
	0x7f, 0xff, 0xef, 0x6f, 0xfb, 0x3f, 0x1e, 0xf7, 0xa7, 0xeb, 0xd9, 0x54, 0xaf, 0xe9, 0x9f, 0x94,
	0x29, 0x1e, 0xdb, 0x63, 0xef, 0x01, 0xfb, 0x1c, 0x0e, 0xcf, 0x4c, 0x21, 0xa2, 0x95, 0xcc, 0x92,
	0xdb, 0x2c, 0xba, 0x77, 0xe2, 0xfd, 0xc2, 0x9b, 0x07, 0x6f, 0xbe, 0x1b, 0xee, 0x7d, 0xfb, 0xdd,
	0x70, 0xef, 0xcd, 0xd5, 0xd0, 0xfb, 0xf6, 0x6a, 0xe8, 0xfd, 0xe7, 0x6a, 0xe8, 0xfd, 0xfd, 0xbf,
	0xc3, 0xbd, 0x45, 0x8b, 0x06, 0xcb, 0xa7, 0xff, 0x0f, 0x00, 0x00, 0xff, 0xff, 0x26, 0xbd, 0xf6,
	0xec, 0x18, 0x0d, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// TalkClient is the client API for Talk service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type TalkClient interface {
	// Talk gets a dialogue answer.
	Talk(ctx context.Context, in *TalkRequest, opts ...grpc.CallOption) (*TalkResponse, error)
	StreamingTalk(ctx context.Context, opts ...grpc.CallOption) (Talk_StreamingTalkClient, error)
}

type talkClient struct {
	cc *grpc.ClientConn
}

func NewTalkClient(cc *grpc.ClientConn) TalkClient {
	return &talkClient{cc}
}

func (c *talkClient) Talk(ctx context.Context, in *TalkRequest, opts ...grpc.CallOption) (*TalkResponse, error) {
	out := new(TalkResponse)
	err := c.cc.Invoke(ctx, "/svpb.Talk/Talk", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *talkClient) StreamingTalk(ctx context.Context, opts ...grpc.CallOption) (Talk_StreamingTalkClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Talk_serviceDesc.Streams[0], "/svpb.Talk/StreamingTalk", opts...)
	if err != nil {
		return nil, err
	}
	x := &talkStreamingTalkClient{stream}
	return x, nil
}

type Talk_StreamingTalkClient interface {
	Send(*TalkRequest) error
	Recv() (*TalkResponse, error)
	grpc.ClientStream
}

type talkStreamingTalkClient struct {
	grpc.ClientStream
}

func (x *talkStreamingTalkClient) Send(m *TalkRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *talkStreamingTalkClient) Recv() (*TalkResponse, error) {
	m := new(TalkResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// TalkServer is the server API for Talk service.
type TalkServer interface {
	// Talk gets a dialogue answer.
	Talk(context.Context, *TalkRequest) (*TalkResponse, error)
	StreamingTalk(Talk_StreamingTalkServer) error
}

// UnimplementedTalkServer can be embedded to have forward compatible implementations.
type UnimplementedTalkServer struct {
}

func (*UnimplementedTalkServer) Talk(ctx context.Context, req *TalkRequest) (*TalkResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Talk not implemented")
}
func (*UnimplementedTalkServer) StreamingTalk(srv Talk_StreamingTalkServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamingTalk not implemented")
}

func RegisterTalkServer(s *grpc.Server, srv TalkServer) {
	s.RegisterService(&_Talk_serviceDesc, srv)
}

func _Talk_Talk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TalkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TalkServer).Talk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/svpb.Talk/Talk",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TalkServer).Talk(ctx, req.(*TalkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Talk_StreamingTalk_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TalkServer).StreamingTalk(&talkStreamingTalkServer{stream})
}

type Talk_StreamingTalkServer interface {
	Send(*TalkResponse) error
	Recv() (*TalkRequest, error)
	grpc.ServerStream
}

type talkStreamingTalkServer struct {
	grpc.ServerStream
}

func (x *talkStreamingTalkServer) Send(m *TalkResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *talkStreamingTalkServer) Recv() (*TalkRequest, error) {
	m := new(TalkRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Talk_serviceDesc = grpc.ServiceDesc{
	ServiceName: "svpb.Talk",
	HandlerType: (*TalkServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Talk",
			Handler:    _Talk_Talk_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamingTalk",
			Handler:       _Talk_StreamingTalk_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "svpb/talk.proto",
}

func (m *TalkRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TalkRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TalkRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsHa {
		i--
		if m.IsHa {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if len(m.InputContext) > 0 {
		i -= len(m.InputContext)
		copy(dAtA[i:], m.InputContext)
		i = encodeVarintTalk(dAtA, i, uint64(len(m.InputContext)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTalk(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Position) > 0 {
		i -= len(m.Position)
		copy(dAtA[i:], m.Position)
		i = encodeVarintTalk(dAtA, i, uint64(len(m.Position)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.TenantCode) > 0 {
		i -= len(m.TenantCode)
		copy(dAtA[i:], m.TenantCode)
		i = encodeVarintTalk(dAtA, i, uint64(len(m.TenantCode)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.RobotID) > 0 {
		i -= len(m.RobotID)
		copy(dAtA[i:], m.RobotID)
		i = encodeVarintTalk(dAtA, i, uint64(len(m.RobotID)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.EnvInfo) > 0 {
		for k := range m.EnvInfo {
			v := m.EnvInfo[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTalk(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTalk(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTalk(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.EventType != 0 {
		i = encodeVarintTalk(dAtA, i, uint64(m.EventType))
		i--
		dAtA[i] = 0x30
	}
	if len(m.QuestionID) > 0 {
		i -= len(m.QuestionID)
		copy(dAtA[i:], m.QuestionID)
		i = encodeVarintTalk(dAtA, i, uint64(len(m.QuestionID)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.SessionID) > 0 {
		i -= len(m.SessionID)
		copy(dAtA[i:], m.SessionID)
		i = encodeVarintTalk(dAtA, i, uint64(len(m.SessionID)))
		i--
		dAtA[i] = 0x22
	}
	if m.AgentID != 0 {
		i = encodeVarintTalk(dAtA, i, uint64(m.AgentID))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Asr.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTalk(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.IsFull {
		i--
		if m.IsFull {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TalkResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TalkResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TalkResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Emotion != nil {
		{
			size, err := m.Emotion.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTalk(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.QuestionID) > 0 {
		i -= len(m.QuestionID)
		copy(dAtA[i:], m.QuestionID)
		i = encodeVarintTalk(dAtA, i, uint64(len(m.QuestionID)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.DebugList) > 0 {
		for iNdEx := len(m.DebugList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DebugList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTalk(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x7a
		}
	}
	if m.HitLog != nil {
		{
			size, err := m.HitLog.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTalk(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.Cost != 0 {
		i = encodeVarintTalk(dAtA, i, uint64(m.Cost))
		i--
		dAtA[i] = 0x68
	}
	if m.Expiration != 0 {
		i = encodeVarintTalk(dAtA, i, uint64(m.Expiration))
		i--
		dAtA[i] = 0x60
	}
	{
		size, err := m.Tree.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTalk(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	if m.GwData != nil {
		{
			size, err := m.GwData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTalk(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.Simqs) > 0 {
		for iNdEx := len(m.Simqs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Simqs[iNdEx])
			copy(dAtA[i:], m.Simqs[iNdEx])
			i = encodeVarintTalk(dAtA, i, uint64(len(m.Simqs[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.Recomendation) > 0 {
		for iNdEx := len(m.Recomendation) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Recomendation[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTalk(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Tags) > 0 {
		for iNdEx := len(m.Tags) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Tags[iNdEx])
			copy(dAtA[i:], m.Tags[iNdEx])
			i = encodeVarintTalk(dAtA, i, uint64(len(m.Tags[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Tts) > 0 {
		for iNdEx := len(m.Tts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTalk(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Confidence != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Confidence))))
		i--
		dAtA[i] = 0x29
	}
	if m.IsCredible {
		i--
		if m.IsCredible {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Operation != nil {
		{
			size, err := m.Operation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTalk(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Asr.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTalk(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Source) > 0 {
		i -= len(m.Source)
		copy(dAtA[i:], m.Source)
		i = encodeVarintTalk(dAtA, i, uint64(len(m.Source)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Emotion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Emotion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Emotion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Score != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Score))))
		i--
		dAtA[i] = 0x11
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTalk(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Asr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Asr) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Asr) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Text) > 0 {
		i -= len(m.Text)
		copy(dAtA[i:], m.Text)
		i = encodeVarintTalk(dAtA, i, uint64(len(m.Text)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Lang) > 0 {
		i -= len(m.Lang)
		copy(dAtA[i:], m.Lang)
		i = encodeVarintTalk(dAtA, i, uint64(len(m.Lang)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AnsItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnsItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AnsItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Outcontext) > 0 {
		i -= len(m.Outcontext)
		copy(dAtA[i:], m.Outcontext)
		i = encodeVarintTalk(dAtA, i, uint64(len(m.Outcontext)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintTalk(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Emoji) > 0 {
		i -= len(m.Emoji)
		copy(dAtA[i:], m.Emoji)
		i = encodeVarintTalk(dAtA, i, uint64(len(m.Emoji)))
		i--
		dAtA[i] = 0x2a
	}
	{
		size, err := m.Action.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTalk(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintTalk(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Lang) > 0 {
		i -= len(m.Lang)
		copy(dAtA[i:], m.Lang)
		i = encodeVarintTalk(dAtA, i, uint64(len(m.Lang)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Text) > 0 {
		i -= len(m.Text)
		copy(dAtA[i:], m.Text)
		i = encodeVarintTalk(dAtA, i, uint64(len(m.Text)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Action) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Action) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Param.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTalk(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Display) > 0 {
		i -= len(m.Display)
		copy(dAtA[i:], m.Display)
		i = encodeVarintTalk(dAtA, i, uint64(len(m.Display)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTalk(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ActionParam) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionParam) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionParam) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Domain) > 0 {
		i -= len(m.Domain)
		copy(dAtA[i:], m.Domain)
		i = encodeVarintTalk(dAtA, i, uint64(len(m.Domain)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.GuideTip) > 0 {
		i -= len(m.GuideTip)
		copy(dAtA[i:], m.GuideTip)
		i = encodeVarintTalk(dAtA, i, uint64(len(m.GuideTip)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.PlayType) > 0 {
		i -= len(m.PlayType)
		copy(dAtA[i:], m.PlayType)
		i = encodeVarintTalk(dAtA, i, uint64(len(m.PlayType)))
		i--
		dAtA[i] = 0x4a
	}
	if m.FrameNo != 0 {
		i = encodeVarintTalk(dAtA, i, uint64(m.FrameNo))
		i--
		dAtA[i] = 0x40
	}
	if m.RawData != nil {
		{
			size, err := m.RawData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTalk(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Params) > 0 {
		for k := range m.Params {
			v := m.Params[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTalk(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTalk(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTalk(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Intent) > 0 {
		i -= len(m.Intent)
		copy(dAtA[i:], m.Intent)
		i = encodeVarintTalk(dAtA, i, uint64(len(m.Intent)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.VideoUrl) > 0 {
		i -= len(m.VideoUrl)
		copy(dAtA[i:], m.VideoUrl)
		i = encodeVarintTalk(dAtA, i, uint64(len(m.VideoUrl)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.PicUrl) > 0 {
		i -= len(m.PicUrl)
		copy(dAtA[i:], m.PicUrl)
		i = encodeVarintTalk(dAtA, i, uint64(len(m.PicUrl)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintTalk(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0x12
	}
	if m.Duration != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Duration))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *Tree) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tree) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tree) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SubTree) > 0 {
		for iNdEx := len(m.SubTree) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SubTree[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTalk(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.CurrentState) > 0 {
		i -= len(m.CurrentState)
		copy(dAtA[i:], m.CurrentState)
		i = encodeVarintTalk(dAtA, i, uint64(len(m.CurrentState)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SubTreeItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubTreeItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubTreeItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Template) > 0 {
		i -= len(m.Template)
		copy(dAtA[i:], m.Template)
		i = encodeVarintTalk(dAtA, i, uint64(len(m.Template)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintTalk(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HitLogDebug) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HitLogDebug) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HitLogDebug) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Parameters) > 0 {
		for k := range m.Parameters {
			v := m.Parameters[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTalk(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTalk(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTalk(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x72
		}
	}
	if len(m.Algo) > 0 {
		i -= len(m.Algo)
		copy(dAtA[i:], m.Algo)
		i = encodeVarintTalk(dAtA, i, uint64(len(m.Algo)))
		i--
		dAtA[i] = 0x6a
	}
	if m.Cost != 0 {
		i = encodeVarintTalk(dAtA, i, uint64(m.Cost))
		i--
		dAtA[i] = 0x60
	}
	if len(m.SupplierType) > 0 {
		i -= len(m.SupplierType)
		copy(dAtA[i:], m.SupplierType)
		i = encodeVarintTalk(dAtA, i, uint64(len(m.SupplierType)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Supplier) > 0 {
		i -= len(m.Supplier)
		copy(dAtA[i:], m.Supplier)
		i = encodeVarintTalk(dAtA, i, uint64(len(m.Supplier)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Time) > 0 {
		i -= len(m.Time)
		copy(dAtA[i:], m.Time)
		i = encodeVarintTalk(dAtA, i, uint64(len(m.Time)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Response) > 0 {
		i -= len(m.Response)
		copy(dAtA[i:], m.Response)
		i = encodeVarintTalk(dAtA, i, uint64(len(m.Response)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.OutContext) > 0 {
		i -= len(m.OutContext)
		copy(dAtA[i:], m.OutContext)
		i = encodeVarintTalk(dAtA, i, uint64(len(m.OutContext)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.InContext) > 0 {
		i -= len(m.InContext)
		copy(dAtA[i:], m.InContext)
		i = encodeVarintTalk(dAtA, i, uint64(len(m.InContext)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Intent) > 0 {
		i -= len(m.Intent)
		copy(dAtA[i:], m.Intent)
		i = encodeVarintTalk(dAtA, i, uint64(len(m.Intent)))
		i--
		dAtA[i] = 0x2a
	}
	if m.IntentId != 0 {
		i = encodeVarintTalk(dAtA, i, uint64(m.IntentId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Domain) > 0 {
		i -= len(m.Domain)
		copy(dAtA[i:], m.Domain)
		i = encodeVarintTalk(dAtA, i, uint64(len(m.Domain)))
		i--
		dAtA[i] = 0x1a
	}
	if m.DomainId != 0 {
		i = encodeVarintTalk(dAtA, i, uint64(m.DomainId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Source) > 0 {
		i -= len(m.Source)
		copy(dAtA[i:], m.Source)
		i = encodeVarintTalk(dAtA, i, uint64(len(m.Source)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTalk(dAtA []byte, offset int, v uint64) int {
	offset -= sovTalk(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *TalkRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsFull {
		n += 2
	}
	l = m.Asr.Size()
	n += 1 + l + sovTalk(uint64(l))
	if m.AgentID != 0 {
		n += 1 + sovTalk(uint64(m.AgentID))
	}
	l = len(m.SessionID)
	if l > 0 {
		n += 1 + l + sovTalk(uint64(l))
	}
	l = len(m.QuestionID)
	if l > 0 {
		n += 1 + l + sovTalk(uint64(l))
	}
	if m.EventType != 0 {
		n += 1 + sovTalk(uint64(m.EventType))
	}
	if len(m.EnvInfo) > 0 {
		for k, v := range m.EnvInfo {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTalk(uint64(len(k))) + 1 + len(v) + sovTalk(uint64(len(v)))
			n += mapEntrySize + 1 + sovTalk(uint64(mapEntrySize))
		}
	}
	l = len(m.RobotID)
	if l > 0 {
		n += 1 + l + sovTalk(uint64(l))
	}
	l = len(m.TenantCode)
	if l > 0 {
		n += 1 + l + sovTalk(uint64(l))
	}
	l = len(m.Position)
	if l > 0 {
		n += 1 + l + sovTalk(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTalk(uint64(l))
	}
	l = len(m.InputContext)
	if l > 0 {
		n += 1 + l + sovTalk(uint64(l))
	}
	if m.IsHa {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TalkResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovTalk(uint64(l))
	}
	l = m.Asr.Size()
	n += 1 + l + sovTalk(uint64(l))
	if m.Operation != nil {
		l = m.Operation.Size()
		n += 1 + l + sovTalk(uint64(l))
	}
	if m.IsCredible {
		n += 2
	}
	if m.Confidence != 0 {
		n += 9
	}
	if len(m.Tts) > 0 {
		for _, e := range m.Tts {
			l = e.Size()
			n += 1 + l + sovTalk(uint64(l))
		}
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovTalk(uint64(l))
		}
	}
	if len(m.Recomendation) > 0 {
		for _, e := range m.Recomendation {
			l = e.Size()
			n += 1 + l + sovTalk(uint64(l))
		}
	}
	if len(m.Simqs) > 0 {
		for _, s := range m.Simqs {
			l = len(s)
			n += 1 + l + sovTalk(uint64(l))
		}
	}
	if m.GwData != nil {
		l = m.GwData.Size()
		n += 1 + l + sovTalk(uint64(l))
	}
	l = m.Tree.Size()
	n += 1 + l + sovTalk(uint64(l))
	if m.Expiration != 0 {
		n += 1 + sovTalk(uint64(m.Expiration))
	}
	if m.Cost != 0 {
		n += 1 + sovTalk(uint64(m.Cost))
	}
	if m.HitLog != nil {
		l = m.HitLog.Size()
		n += 1 + l + sovTalk(uint64(l))
	}
	if len(m.DebugList) > 0 {
		for _, e := range m.DebugList {
			l = e.Size()
			n += 1 + l + sovTalk(uint64(l))
		}
	}
	l = len(m.QuestionID)
	if l > 0 {
		n += 2 + l + sovTalk(uint64(l))
	}
	if m.Emotion != nil {
		l = m.Emotion.Size()
		n += 2 + l + sovTalk(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Emotion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTalk(uint64(l))
	}
	if m.Score != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Asr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Lang)
	if l > 0 {
		n += 1 + l + sovTalk(uint64(l))
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovTalk(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AnsItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovTalk(uint64(l))
	}
	l = len(m.Lang)
	if l > 0 {
		n += 1 + l + sovTalk(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTalk(uint64(l))
	}
	l = m.Action.Size()
	n += 1 + l + sovTalk(uint64(l))
	l = len(m.Emoji)
	if l > 0 {
		n += 1 + l + sovTalk(uint64(l))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovTalk(uint64(l))
	}
	l = len(m.Outcontext)
	if l > 0 {
		n += 1 + l + sovTalk(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Action) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTalk(uint64(l))
	}
	l = len(m.Display)
	if l > 0 {
		n += 1 + l + sovTalk(uint64(l))
	}
	l = m.Param.Size()
	n += 1 + l + sovTalk(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ActionParam) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Duration != 0 {
		n += 9
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovTalk(uint64(l))
	}
	l = len(m.PicUrl)
	if l > 0 {
		n += 1 + l + sovTalk(uint64(l))
	}
	l = len(m.VideoUrl)
	if l > 0 {
		n += 1 + l + sovTalk(uint64(l))
	}
	l = len(m.Intent)
	if l > 0 {
		n += 1 + l + sovTalk(uint64(l))
	}
	if len(m.Params) > 0 {
		for k, v := range m.Params {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTalk(uint64(len(k))) + 1 + len(v) + sovTalk(uint64(len(v)))
			n += mapEntrySize + 1 + sovTalk(uint64(mapEntrySize))
		}
	}
	if m.RawData != nil {
		l = m.RawData.Size()
		n += 1 + l + sovTalk(uint64(l))
	}
	if m.FrameNo != 0 {
		n += 1 + sovTalk(uint64(m.FrameNo))
	}
	l = len(m.PlayType)
	if l > 0 {
		n += 1 + l + sovTalk(uint64(l))
	}
	l = len(m.GuideTip)
	if l > 0 {
		n += 1 + l + sovTalk(uint64(l))
	}
	l = len(m.Domain)
	if l > 0 {
		n += 1 + l + sovTalk(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Tree) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CurrentState)
	if l > 0 {
		n += 1 + l + sovTalk(uint64(l))
	}
	if len(m.SubTree) > 0 {
		for _, e := range m.SubTree {
			l = e.Size()
			n += 1 + l + sovTalk(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SubTreeItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovTalk(uint64(l))
	}
	l = len(m.Template)
	if l > 0 {
		n += 1 + l + sovTalk(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HitLogDebug) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovTalk(uint64(l))
	}
	if m.DomainId != 0 {
		n += 1 + sovTalk(uint64(m.DomainId))
	}
	l = len(m.Domain)
	if l > 0 {
		n += 1 + l + sovTalk(uint64(l))
	}
	if m.IntentId != 0 {
		n += 1 + sovTalk(uint64(m.IntentId))
	}
	l = len(m.Intent)
	if l > 0 {
		n += 1 + l + sovTalk(uint64(l))
	}
	l = len(m.InContext)
	if l > 0 {
		n += 1 + l + sovTalk(uint64(l))
	}
	l = len(m.OutContext)
	if l > 0 {
		n += 1 + l + sovTalk(uint64(l))
	}
	l = len(m.Response)
	if l > 0 {
		n += 1 + l + sovTalk(uint64(l))
	}
	l = len(m.Time)
	if l > 0 {
		n += 1 + l + sovTalk(uint64(l))
	}
	l = len(m.Supplier)
	if l > 0 {
		n += 1 + l + sovTalk(uint64(l))
	}
	l = len(m.SupplierType)
	if l > 0 {
		n += 1 + l + sovTalk(uint64(l))
	}
	if m.Cost != 0 {
		n += 1 + sovTalk(uint64(m.Cost))
	}
	l = len(m.Algo)
	if l > 0 {
		n += 1 + l + sovTalk(uint64(l))
	}
	if len(m.Parameters) > 0 {
		for k, v := range m.Parameters {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTalk(uint64(len(k))) + 1 + len(v) + sovTalk(uint64(len(v)))
			n += mapEntrySize + 1 + sovTalk(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovTalk(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTalk(x uint64) (n int) {
	return sovTalk(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TalkRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalk
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TalkRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TalkRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFull", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFull = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Asr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgentID", wireType)
			}
			m.AgentID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AgentID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuestionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QuestionID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			m.EventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventType |= EventType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnvInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EnvInfo == nil {
				m.EnvInfo = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTalk
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTalk
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTalk
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTalk
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTalk
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTalk
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTalk
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTalk(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTalk
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.EnvInfo[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RobotID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RobotID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TenantCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Position = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputContext", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputContext = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsHa", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsHa = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTalk(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalk
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTalk
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TalkResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalk
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TalkResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TalkResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Asr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Operation == nil {
				m.Operation = &types.Struct{}
			}
			if err := m.Operation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCredible", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsCredible = bool(v != 0)
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Confidence", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Confidence = float64(math.Float64frombits(v))
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tts = append(m.Tts, AnsItem{})
			if err := m.Tts[len(m.Tts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recomendation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Recomendation = append(m.Recomendation, AnsItem{})
			if err := m.Recomendation[len(m.Recomendation)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Simqs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Simqs = append(m.Simqs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GwData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GwData == nil {
				m.GwData = &types.Struct{}
			}
			if err := m.GwData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tree", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Tree.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expiration", wireType)
			}
			m.Expiration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expiration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cost", wireType)
			}
			m.Cost = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cost |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HitLog", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HitLog == nil {
				m.HitLog = &types.Struct{}
			}
			if err := m.HitLog.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebugList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DebugList = append(m.DebugList, HitLogDebug{})
			if err := m.DebugList[len(m.DebugList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuestionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QuestionID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Emotion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Emotion == nil {
				m.Emotion = &Emotion{}
			}
			if err := m.Emotion.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTalk(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalk
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTalk
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Emotion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalk
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Emotion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Emotion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Score = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipTalk(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalk
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTalk
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Asr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalk
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Asr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Asr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lang", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Lang = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTalk(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalk
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTalk
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnsItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalk
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnsItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnsItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lang", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Lang = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Action.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Emoji", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Emoji = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Outcontext", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Outcontext = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTalk(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalk
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTalk
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Action) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalk
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Action: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Action: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Display", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Display = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Param", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Param.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTalk(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalk
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTalk
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionParam) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalk
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionParam: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionParam: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Duration = float64(math.Float64frombits(v))
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PicUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PicUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VideoUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VideoUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Intent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Intent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTalk
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTalk
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTalk
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTalk
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTalk
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTalk
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTalk
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTalk(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTalk
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Params[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RawData == nil {
				m.RawData = &types.Value{}
			}
			if err := m.RawData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrameNo", wireType)
			}
			m.FrameNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FrameNo |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlayType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuideTip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuideTip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTalk(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalk
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTalk
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tree) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalk
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tree: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tree: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentState", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CurrentState = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubTree", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubTree = append(m.SubTree, SubTreeItem{})
			if err := m.SubTree[len(m.SubTree)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTalk(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalk
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTalk
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubTreeItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalk
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubTreeItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubTreeItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Template", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Template = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTalk(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalk
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTalk
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HitLogDebug) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTalk
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HitLogDebug: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HitLogDebug: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainId", wireType)
			}
			m.DomainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DomainId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntentId", wireType)
			}
			m.IntentId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IntentId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Intent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Intent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InContext", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InContext = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutContext", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutContext = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Time = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Supplier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Supplier = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupplierType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SupplierType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cost", wireType)
			}
			m.Cost = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cost |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Algo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Algo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTalk
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTalk
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Parameters == nil {
				m.Parameters = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTalk
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTalk
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTalk
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTalk
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTalk
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTalk
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTalk
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTalk(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTalk
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Parameters[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTalk(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTalk
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTalk
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTalk(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTalk
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTalk
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTalk
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTalk
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTalk
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTalk        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTalk          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTalk = fmt.Errorf("proto: unexpected end of group")
)
